# Описание проекта

Сайт с парсингом фильмов с КинопоискApi

# Запуск проекта

Для запуска проекта необходимо использовать powershell и две команды

`$env:REACT_APP_API_KEY="YOUR_API_TOKEN"`

`npm start`

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/62ea2dd0-48aa-43f5-b039-3272606e6629/36b99bc3-5c4f-4e5a-938f-998d4a8ee91b/Untitled.png)

# Функционирование проекта

### Стек:

1. React, React-router v6.22.3.
2. Настроенный Webpack. В дальнейшем можно будет легко добавить новые плагины и лоудеры.
3. TypeScript. Помогает с проблемой отсутствия типизации, сильно экономит время при поиске ошибок, позволяет типизировать ответ с сервера.
4. FSD. Методология, позволяющая структурировать проект. Благодаря этому приложение делится на слои и слайсы, которые взаимодействуют друг с другом по определенным схемам. По сути это просто набор папок и структуризация проекта, чтобы по нему можно было легко перемещаться.
5. ReduxToolkit/RTK Query
    
    Так как сайт разделен на несколько панелей, которые находятся на разных слоях. Например, панель отображения карточек фильмов и панель фильтров, нужен был отдельный глобальный стейт. В моём случае это store из redux. Так, я собираю информацию о фильтрах из панели фильтров, помещаю её в store, затем достаю в нужном месте с помощью useAppSelector(). TypeScript полностью сопровождает этот процесс от помещения информации в store, до использования её в компонентах. Точно также я использовал redux с панелью поиска. Она полностью независима от других компонентов, а эти компоненты используют из неё определенные данные.
    
    RTK используется для запросов к серверу. Это удобная альтернатива тому же axios, которая устанавливается вместе с ReduxToolkit. Из причин почему её стоит использовать можно выделить, например, кеширование http запросов. А т.к. сайт получает много данных с KinoPoiskApi, можно лишний раз не делать запрос к серверу, а взять их из кеша. Также в RTK можно использовать асинхронные вызовы API.
    
6. Tailwind. Мне просто нравится этот css фреймворк, можно сразу писать все стили к classNames, к тому же по дефолту устанавливает хорошие обнуляющие стили. Также использовал библиотеки компонентов, работающие с Tailwind: material-tailwind и headless ui
